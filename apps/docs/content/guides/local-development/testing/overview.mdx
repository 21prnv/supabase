---
id: 'local-development-testing-overview'
title: 'Testing Overview'
description: 'Learn how develop and test your database schema, tables, functions, and Row Level Security (RLS) policies.'
---

Testing is a critical part of database development, especially when working with features like Row Level Security (RLS) policies. This guide provides a comprehensive approach to testing your Supabase database.

## Quick Start: Testing RLS in 15 Minutes

Let's walk through a complete example of setting up and testing RLS policies for a simple todo application:

1. Create a test table with RLS enabled:

```sql
-- Create a simple todos table
create table todos (
  id uuid primary key default gen_random_uuid(),
  task text not null,
  user_id uuid references auth.users not null,
  completed boolean default false
);

-- Enable RLS
alter table todos enable row level security;

-- Create a policy
create policy "Users can only access their own todos"
on todos for all -- this policy applies to all operations
to authenticated
using (auth.uid() = user_id);
```

2. Set up your testing environment:

```bash
# Create test directory
mkdir -p ./supabase/tests/database

# Enable pgTAP extension if not already enabled
supabase sql 'create extension if not exists pgtap with schema extensions;'

# Create test file
touch ./supabase/tests/database/todos_rls.test.sql
```

3. Write your RLS tests:

```sql
begin;
select plan(6);

-- Test 1: Verify RLS is enabled
select has_row_level_security('public'::name, 'todos'::name);

-- Test 2: Verify policy exists
select policies_are('public', 'todos', ARRAY['Users can only access their own todos']);

-- Set up test data
insert into auth.users (id, email) values
  ('d0c2eb55-5c60-4415-93f9-8743b3b0743e', 'user1@test.com'),
  ('51f0518c-0d3b-4937-b98f-2a50b8aa1997', 'user2@test.com');

insert into public.todos (task, user_id) values
  ('User 1 Task 1', 'd0c2eb55-5c60-4415-93f9-8743b3b0743e'),
  ('User 1 Task 2', 'd0c2eb55-5c60-4415-93f9-8743b3b0743e'),
  ('User 2 Task 1', '51f0518c-0d3b-4937-b98f-2a50b8aa1997');

-- Test as User 1
set local role authenticated;
set local "request.jwt.claims" to '{"sub": "d0c2eb55-5c60-4415-93f9-8743b3b0743e"}';

-- Test 3: User 1 should only see their own todos
select results_eq(
  'select count(*) from todos',
  ARRAY[2::bigint],
  'User 1 should only see their 2 todos'
);

-- Test 4: User 1 can create their own todo
select lives_ok(
  $$insert into todos (task, user_id) values ('New Task', 'd0c2eb55-5c60-4415-93f9-8743b3b0743e')$$,
  'User 1 can create their own todo'
);

-- Test as User 2
set local "request.jwt.claims" to '{"sub": "51f0518c-0d3b-4937-b98f-2a50b8aa1997"}';

-- Test 5: User 2 should only see their own todos
select results_eq(
  'select count(*) from todos',
  ARRAY[1::bigint],
  'User 2 should only see their 1 todo'
);

-- Test 6: User 2 cannot modify User 1's todo
select throws_ok(
  $$update todos set task = 'Hacked!' where user_id = 'd0c2eb55-5c60-4415-93f9-8743b3b0743e'$$,
  'User 2 cannot modify User 1 todos'
);

select * from finish();
rollback;
```

4. Run the tests:

```bash
supabase test db
```

## Testing Approaches

### 1. Database Unit Testing with pgTAP

[pgTAP](https://pgtap.org) is a unit testing framework for PostgreSQL that allows you to test:

- Database structure (tables, columns, constraints)
- Row Level Security (RLS) policies
- Functions and procedures
- Data integrity

#### Common pgTAP Testing Patterns

1. Testing Database Structure:

```sql
begin;
select plan(4);

-- Test table existence
select has_table('public', 'todos', 'Table todos should exist');

-- Test column existence
select has_column('public', 'todos', 'task', 'Column task should exist');
select has_column('public', 'todos', 'user_id', 'Column user_id should exist');

-- Test foreign key constraint
select col_is_fk('public', 'todos', 'user_id', 'user_id should be a foreign key');

select * from finish();
rollback;
```

2. Testing RLS Policies with Different Roles:

```sql
begin;
select plan(3);

-- Test anonymous access
set local role anon;
select results_eq(
  'select count(*) from todos',
  ARRAY[0::bigint],
  'Anonymous users should see no todos'
);

-- Test authenticated access with correct user
set local role authenticated;
set local "request.jwt.claims" to '{"sub": "user-id"}';
select results_eq(
  'select count(*) from todos where user_id = ''user-id''',
  ARRAY[1::bigint],
  'User should see their own todos'
);

-- Test authenticated access with wrong user
set local "request.jwt.claims" to '{"sub": "wrong-user"}';
select results_eq(
  'select count(*) from todos where user_id = ''user-id''',
  ARRAY[0::bigint],
  'User should not see other users todos'
);

select * from finish();
rollback;
```

### 2. Application-Level Testing

Testing through your application code provides end-to-end verification. Here's an example using TypeScript and Jest:

```typescript
import { createClient } from '@supabase/supabase-js'

describe('Todos RLS', () => {
  const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!)

  it('should enforce RLS policies', async () => {
    // Sign in as user 1
    const {
      data: { user: user1 },
    } = await supabase.auth.signInWithPassword({
      email: 'user1@test.com',
      password: 'password123',
    })

    // Create a todo as user 1
    const { data: todo } = await supabase
      .from('todos')
      .insert({ task: 'Test task', user_id: user1.id })
      .select()
      .single()

    // Sign in as user 2
    await supabase.auth.signInWithPassword({
      email: 'user2@test.com',
      password: 'password123',
    })

    // Try to access user 1's todo
    const { data: user2Todos } = await supabase.from('todos').select().eq('id', todo.id)

    expect(user2Todos).toHaveLength(0) // User 2 should not see User 1's todo
  })
})
```

### 3. Continuous Integration (CI) Testing

Set up automated database testing in your CI pipeline:

1. Create a GitHub Actions workflow (`.github/workflows/db-tests.yml`):

```yaml
name: Database Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1

      - name: Start Supabase
        run: supabase start

      - name: Run Tests
        run: supabase test db
```

## Best Practices

1. **Test Data Setup**

   - Use `begin;` and `rollback;` to ensure test isolation
   - Create realistic test data that covers edge cases
   - Use different user roles and permissions in your tests

2. **RLS Policy Testing**

   - Test all CRUD operations (SELECT, INSERT, UPDATE, DELETE)
   - Test with different user roles (anonymous, authenticated)
   - Test edge cases and potential security bypasses
   - Always test negative cases (what users shouldn't be able to do)

3. **CI/CD Integration**
   - Run tests automatically on every pull request
   - Include database tests in your deployment pipeline
   - Keep test runs fast by using transactions

## Real-World Examples

For more complex, real-world examples of database testing, check out:

- [Basejump's Database Tests](https://github.com/usebasejump/basejump/tree/main/supabase/tests/database) - A production-grade example of testing RLS policies

## Troubleshooting

Common issues and solutions:

1. **Test Failures Due to RLS**

   - Ensure you've set the correct role (`set local role authenticated;`)
   - Verify JWT claims are set (`set local "request.jwt.claims"`)
   - Check policy definitions match your test assumptions

2. **CI Pipeline Issues**
   - Verify Supabase CLI is properly installed
   - Ensure database migrations are run before tests
   - Check for proper test isolation using transactions

## Additional Resources

- [pgTAP Documentation](https://pgtap.org)
- [Supabase CLI Reference](https://supabase.com/docs/reference/cli/supabase-test)
